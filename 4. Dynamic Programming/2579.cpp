#include <cstdio>
using namespace std;
int max(int a, int b){return a>b?a:b;}
int a[301], d[301];
signed main()
{
    int n; scanf("%d", &n);
    for(int i=1;i<=n;++i)
        scanf("%d", &a[i]);
    d[1] = a[1];
    d[2] = a[1] + a[2];
    d[3] = max(a[1], a[2]) + a[3];
    for (int i=4;i<=n;++i)
        d[i] = max(d[i-3]+a[i-1], d[i-2]) + a[i];
    printf("%d\n", d[n]);
    return 0;
}
/*
 문제가 되는 것이 연속 세 계단을 못 밟는 것과 마지막 계단은 무조건 밟아야 한다는 조건이다.
 하지만 마지막 계단부터 밟는다면 어떨까? 첫번째 계단을 무조건 밟을 필요가 없다. 
 점화식을 한번 세워보자. D[i]: i번째 계단까지 얻는 최대값(i번째 계단은 무조건 밟아야 함). 
 현재 내가 i번째 칸에 있다고 쳐보자. 
 이때 마지막 이동은 한발짝 이동과 두발짝 이동이 있다. 
 두발짝 이동한 경우 D[i-2] + a[i]가 되며, 이 경우 두발짝 이동으로 인하여, 연속하여 3개를 밟지 않은것이 된다. 
 한발짝 이동의 경우 연속해서 2개의 칸을 밟게 된 것이며, 이것의 전 이동은 절때 한발짝 이동이 될 수 없다. 
 그러므로 전 이동은 두발짝 이동이여야만 한다. 
 즉 두발짝+한발짝 이동 조합이며 이를 dp식으로 나타내면 D[i] = D[i-3] + a[i-1] + a[i]가 된다
 */
