# 2. 완전탐색과 분할 정복
PS를 할 때 가장 먼저 고려해야할 풀이는 문제에 주어진 그대로 "무식하게 푸는 것"입니다. 간과하기 쉬운 것이, 이 무식한 풀이로 풀리는 문제가 꽤 많은데 불구하고 많은 사람들은 쉬운 문제에 너무 어렵게 접근하곤 합니다. 오늘 다룰 알고리즘은 완전 탐색(brute-force)과 분할 정복(divide-and-conquer)입니다.  

## 완전 탐색 (brute-force) 👊
PS에서 "무식하게 푼다"라고 함은 가능한 경우의 수를 일일이 나열하면서 답은 찾는 방법을 의미합니다.  
이 알고리즘을 <b>완전 탐색(brute-force)</b>이라고 부르죠.  

이게 전부입니다. 처음 접하는 분들은 이런 것도 알고리즘으로 다룰 필요가 있을까 싶겠지만, 사실 컴퓨터와 가장 잘 어울리는 알고리즘이 완전 탐색입니다. 컴퓨터의 빠른 연산 속도를 잘 이용하기에 좋은 방법이죠. 그리고 이 완전 탐색을 구현하는 것이 생각만큼 쉽지만은 않습니다. 완전 탐색 문제를 잘 풀려면 충분한 구현력을 갖춰야죠.  

바로 문제 풀이를 통해 알아보겠습니다.  

### 예제 🎲


--- 

## 분할 정복 (divide-and-conquer) ✂
분할 정복은 가장 유명한 알고리즘 디자인 패러다임입니다. 분할 정복 페러다임을 차용한 알고리즘들이 많기에, 잘 짚고 넘어가는 것이 좋습니다. 분할 정복(divide-and-conquer)이란 문제를 비슷한 크기를 가진 부분 문제들로 나누는 것입니다. 분할 정복을 사용하는 알고리즘들은 대개 세 가지의 구성 요소를 가지고 있습니다.  

1. 문제를 더 작은 문제로 분할하는 과정(divide)  
2. 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정(merge)  
3. 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제(base case)  

분할 정복의 가장 큰 장점은 빠른 속도입니다. 많은 경우 <img src="https://latex.codecogs.com/svg.latex?O(log(n))"/> 또는 <img src="https://latex.codecogs.com/svg.latex?O(n%20log(n))"/> 의 시간복잡도를 갖습니다. 
참고로 <img src="https://latex.codecogs.com/svg.latex?O(log(n))"/> 의 알고리즘은 <img src="https://latex.codecogs.com/svg.latex?O(1)"/> 에 가까운 실행 속도를 보입니다.  

문제 풀이를 통해 어떻게 분할 정복이 쓰이는지 알아보겠습니다.  

### 예제 🎲


---

## 연습 🏓
#### 완전 탐색
#### 분할 정복
#### Challenge ⚡
