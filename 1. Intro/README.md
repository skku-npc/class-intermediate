# 1. 문제 해결 전략
문제 해결은 흔히 Problem Solving, 줄여서 PS라고 하죠. 앞으로는 PS로 칭하겠습니다.  
(사실 PS는 CP(Competitive Programming)과 구분되지만, 저는 둘을 묶어 PS로 부르겠습니다. [참고 설명](https://namnamseo.tistory.com/entry/PS-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC))  

여러분은 PS를 하는 이유가 뭔가요? 코딩테스트? 코딩 실력 향상? 그냥 재밌어서? 사실 PS 하는데 별 이유가 필요하진 않습니다. 재밌어서 하는게 최고죠. (저도 그렇고요 ㅎㅎ) 하지만 그렇지 못한 분들도 많죠. 그런 분들께 이 스터디가 흥미의 계기가 되었으면 좋겠습니다.  

이번 장은 본격적인 스터디에 앞선 동기 부여와, PS의 소개, 그리고 기본적인 개념을 익히기 위해 준비했습니다.

## PS의 중요성 🎈
좋은 개발자의 조건은 무엇일까요? 프로그래밍에는 여러 제약 사항이 있습니다. 프로그래밍 언어의 특성, 하드웨어와 운영체제에 관한 지식, 사용하고 있는 라이브러리들에 대한 유의사항, 시간 제한, 재사용성이 높은 코드 등등 신경 쓸 사항이 정말 많죠. 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력은 좋은 프로그래머가 되기 위해 필수적입니다. 이러한 능력은 곧 '문제 해결 능력'이라는 단어로 일컬어집니다. PS는 바로 이 <b>문제 해결 능력을 키우기 아주 좋은 방법</b> 중 하나입니다.  

일반적인 프로그램 작성과 PS가 다른 점은 다음과 같습니다.

__1. 텍스트 입출력__  
PS에서 작성하는 프로그램은 그래픽 인터페이스를 사용하지 않습니다. 오로지 텍스트 파일의 입출력만 사용하죠. 따라서 프로그램을 작성하면서 여러 곳에 신경 쓸 필요 없이 문제 해결에 집중할 수 있습니다.  

__2. 시간 제한 & 메모리 제한__  
PS에는 명시적인 시간 제한과 메모리 제한이 있습니다. PS 문제들은 프로그램의 수행 시간이 데이터베이스, 네트워크 접근 등이 아니라 CPU를 통한 계산에 대부분 소비되기 때문에, 적절한 알고리즘과 자료 구조를 사용하는 것이 필수입니다. 따라서 PS는 직접 신중하게 알고리즘을 설계해보는 경험이 됩니다. 이미 알려진 알고리즘을 그대로 사용하는 것이 아니라, 알고리즘의 원칙을 잘 이해하고 변형해야 풀 수 있는 문제들이 많기에 알고리즘에 대한 깊은 이해에 큰 도움이 됩니다.  

__3. 객관적인 피드백__  
정답과 오답의 여부가 명확히 가려집니다. 현업에서는 대개 코드의 정당성을 코드 리뷰나 유닛 테스트로 검증하는데, PS에서는 이보다 훨씬 다양하고 큰 입력으로 프로그램을 시험하기에 오류를 찾기 쉽습니다. 또한 대부분의 경우 프로그램의 정답 여부를 제출 직후 알 수 있어, PS는 예외 없는 정확한 프로그램을 짜는 좋은 훈련이 됩니다.  

__4. 소규모 프로그램__  
커다란 프로그램을 다룰 때에는 코드의 구조를 변경하기도 어렵고, 구조를 위해 우아함을 희생해야하는 경우가 종종 있습니다. 하지만 PS에서는 소규모 프로그램을 처음부터 직접 작성하기 때문에, 간결하고 우아한 프로그램을 짜는 데에 시간을 들이며 좋은 코드를 작성하는 연습을 할 수 있습니다.  

__5. 여러 사람과의 경쟁__  
경쟁은 실력을 늘리기 위한 좋은 동기가 되기도 합니다. 현업에서는 두 사람 이상이 같은 문제에 대한 코드를 동시에 작성하는 일이 거의 없지만, PS에서는 여러 사람이 같은 문제를 풀기 때문에 전 세계의 고수 프로그래머들이 짠 코드를 직접 참고해볼 기회가 됩니다.  

## 관련 조언 ☝
PS에서 가장 중요한 것은 결국 <b>최대한 많이 풀어보는 것</b>입니다. 초보자든, 중급자든, 고수든 이것만큼은 모두에게 적용된다고 생각합니다. 뒤에서도 얘기하겠지만, PS에서 직관과 경험은 크게 작용합니다. 이를 키우는 방법은 결국 어찌 됐든 많이 경험해보는 수밖에 없습니다.  

PS 입문자들이 주로 하는 실수가 알고리즘 주제의 양에 압도되어, 배경지식을 익히는 데에 시간을 할애하곤 합니다. 하지만 배경지식이 아무리 많아도 이를 충분히 활용할 능력이 없다면 쓸모없다는 것은 당연합니다. 이 능력은 오로지 충분한 경험을 통해서만 얻어질 수 있습니다. 그러니 절대 지식만 늘리는 데에 급급해하지 말고, 하나씩 확실하게 익힌다는 마음가짐으로 경험을 쌓는 것을 우선시해주세요.

#### 참고 사이트
PS에는 여러 사이트가 있습니다. 보통 OJ(Online Judge, 채점 사이트)와 대회 사이트로 나뉘는데, OJ로는 대표적으로 백준이 있습니다. 백준은 워낙 유명하니 당연히 알거라고 생각하고 설명은 생략하겠습니다. 제 생각에는 백준에 올라와있는 문제량이 워낙 방대한 터라 초중급자들은 굳이 다른 OJ를 이용하지 않아도 될거라고 생각합니다. 참고로 [solved.ac](solved.ac)에 난이도 등이 정리가 잘 되어있어 함께 이용하면 좋습니다.  

대회 사이트는 모르는 분들이 종종 있는 것 같은데, 제가 권하고 싶은 사이트는 이 중 Codeforces와 AtCoder입니다. 둘 다 프로그래밍 모의고사를 진행하는 사이트로, 보통 두 시간 정도의 제한시간을 갖고 진행합니다. 매주 1 ~ 3회 정도로 꽤 자주 열리고, 레이팅 시스템도 있으니 나름 재미있게 프로그래밍 대회를 연습해볼 기회가 됩니다. 이는 아직 안해보신 분들은 꼭 해보시길 권장합니다!

---

## 문제 접근법 🔑
이제 PS의 기술에 대해 이야기해보겠습니다. 사실 어찌 보면 굉장히 뻔하고, 기본적인 이야기일 수 있지만 막상 돌아보면 실천하고 있지 못한 것들도 꽤나 많습니다. 이 사항들만 잘 실천해도 풀 수 있는 문제 수가 늘어나는 것은 물론, 문제 풀이 속도도 꽤 빨라질 것입니다.  

강력한 문제 해결 알고리즘으로 알려진 파인만 알고리즘에 대해 우선 소개하겠습니다.  
1. 칠판에 문제를 적는다.  
2. 골똘히 생각한다.  
3. 칠판에 답안을 적는다.  

사실 농담삼아 얘기하는 내용이긴 하지만, 이 알고리즘도 분명 배울 점은 있습니다.  
이렇게 문제 해결을 단계별로 나누는 것은 생각보다 중요한 아이디어입니다.  

이제 종만북에 서술된 대로 PS의 과정을 몇 단계로 나눠보겠습니다.  

__1. 문제를 읽고 이해하기__  
분명 어려운 단계가 아니지만, 아주 중요한 단계입니다. 여러분도 학창시절 수학 문제 풀 때 문제를 잘못 읽어서 실수한 적이 종종 있을겁니다. PS에서도 고수들을 포함한 정말 많은 사람들이 문제를 잘못 읽는 실수를 범합니다. 시간에 쫓기는 프로그래밍 대회에서 이런 실수를 범하기 정말 쉽지만, 침착하게 문제를 완전하게 이해하는 과정은 반드시 필요합니다. 앞서 말했듯이 PS는 채점이 엄격하게 이뤄지기에 실수는 크게 작용합니다.  

__2. 재정의와 추상화__  
재정의는 문제를 자신의 언어로 풀어 쓰는 것, 추상화는 수학적/전산학적 개념으로 옮겨 표현하는 것을 말합니다. 즉, 주어진 문제를 쉽게 만들어 앞으로 나아갈 방향을 정하는 과정입니다. 개인적으로는 이 단계를 크게 강조하고 싶습니다. 문제를 추상화하는 이 과정을 건너뛰는 경우가 꽤 많은데, 이 추상화가 잘 이뤄지면 나머지 단계들이 훨씬 수월하게 진행될 수 있습니다.  

__3. 계획 세우기__  
문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료구조를 선택합니다.  
사실상 이 부분이 PS에서 가장 중요한 단계라고 볼 수 있죠.  

__4. 계획 검증하기__  
본격적인 구현에 앞서, 우리가 설계한 알고리즘이 요구 조건에 맞는지 검증해봅니다.  
즉, 예외 처리는 잘 되었는지, 수행 시간과 사용 메모리가 조건에 맞는지 등을 확인합니다.  

__5. 계획 수행하기__  
자신의 계획을 직접 코드로 작성합니다. 이 과정에서 정확하고 빠른 구현 능력이 요구됩니다.  

__6. 회고하기__  
자신이 문제를 해결한 과정을 돌이켜 보고 개선하는 과정을 말합니다. 흔히 Upsolving이라고 부르는 과정과 비슷한 단계입니다. 장기적인 실력 향상을 위해서는 반드시 필요한 단계죠. 회고에는 여러 방법이 있습니다. 더 효율적인 알고리즘을 찾거나 간결한 코드를 작성할 수도 있고, 같은 알고리즘을 유도하는 더 직관적인 방법을 찾을 수도 있습니다. (저는 귀찮아서 하진 않지만) 오답노트처럼 자신의 코드와 함께 자신의 경험을 기록으로 남기는 방법도 있죠. 이는 자신이 배운 내용을 되새길 때도 유용하고, 비슷한 문제를 패턴화 시키는 데에도 유리합니다. 제가 권장하는 다른 방법으로는 같은 문제를 해결한 다른 사람의 코드를 읽어보는 것입니다. 다른 사람으로부터 자극을 얻을 뿐만 아니라, 자신이 생각치 못했던 여러 통찰들을 얻어갈 수 있습니다.  

## 유용한 질문들 💡
물론 위의 단계를 거친다고 모든 알고리즘 문제가 해결되는 것은 아닙니다.  
이 경우 다음과 같은 질문들을 통해 해결법에 대한 좋은 직관을 얻을 수 있습니다.

- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 푸는 과정을 수식화할 수 있을까?
- 문제를 단순화할 수 있을까?
- 문제를 분해할 수 있을까?
- 문제를 뒤에서부터 생각하면 어떨까?

---

## 기초 개념 📌
종만북 3장에 여러 유용한 설명들이 있지만, 이는 대부분 PS에 익숙해진 후에 이해될 내용이라고 생각해 생략하도록 하겠습니다. 아직 PS에 익숙치 못한 분들은 이번 학기가 끝나고 PS에 자신이 생기면 종만북 3장을 한 번 읽어보는 것을 추천드립니다.  

이 부분에서는 알고리즘의 핵심이라고 볼 수 있는 <b>시간 복잡도 분석</b>을 간략히 짚고 넘어가겠습니다.  

#### 알고리즘의 속도 측정
알고리즘의 속도를 측정하는 것은 두말할 나위 없이 중요합니다. 그렇다면 두 알고리즘의 속도를 어떤 방법으로 비교할까요? 가장 직관적인 방법은 같은 입력에 대해 두 알고리즘의 수행 속도를 비교하는 것입니다. 이는 때로는 유용한 방법이지만, 다음과 같은 이유로 좋은 방법이 아닙니다. 

가장 큰 이유는 일반적으로는 프로그래밍 언어, 컴파일러, 운영체제, 하드웨어 등 수많은 변수에 따라 수행 시간이 바뀔 수 있습니다. 이외에도 함수 인자를 넘기는 방법, 문자열 구현 방법 등의 요소가 있습니다. 다른 이유는 실제 수행 시간은 다양한 입력에 대한 실행 시간을 반영하기 어렵다는 것입니다. 입력의 크기와 특성에 따라 수행 시간은 크게 달라질 수 있습니다.  

#### 시간 복잡도
이를 보완하는 좋은 방법이 시간 복잡도를 이용하는 것입니다. 시간복잡도의 정의는 "<u>문제를 해결하는데 걸리는 시간과 입력의 함수 관계</u>"라고 합니다. 알고리즘의 평가 지표는 시간복잡도(time complexity), 공간복잡도(space complexity) 두 가지로 나뉘는데 서로 비슷한 개념이니 시간복잡도만 설명하겠습니다.  

연산은 다음과 같이 세 경우로 나눌 수 있습니다.
1. 최선의 경우 (best case)
2. 최악의 경우 (worst case)
3. 평균적인 경우 (average case)

일반적으로는 <b>최악의 경우</b>로 알고리즘의 성능을 파악합니다. PS에서는 아무리 평균적인 성능이 좋을 지라도, test case 중 edge case 하나만 실패해도 바로 WA(Wrong Answer)나 TLE(Time Limit Exceed)를 받기 때문에 최악의 경우의 성능이 중요합니다.  

#### Big O 표기법
이 시간 복잡도는 Big O 표기법으로 나타냅니다. 예시는 다음과 같습니다.  
<img src="https://feel5ny.github.io/images/post_img/48/02.png" width=600>  

위 예를 보면 T(n)의 최고차항의 차수가 big-O가 되는 것을 볼 수 있습니다. 알고리즘에서 이 big-O가 클수록 연산 횟수가 많음을 뜻하고 따라서 성능이 나쁘다는 것을 보입니다.  

여러 big-O를 비교하면 다음 그래프와 같습니다.  

<img src="https://feel5ny.github.io/images/post_img/48/03.png" width=600>  
<img src="https://feel5ny.github.io/images/post_img/48/05.png" width=600>  
<img src="https://feel5ny.github.io/images/post_img/48/04.png" width=600>  

좀 더 자세한 내용은 다음 링크를 참고해주세요: https://feel5ny.github.io/2017/12/09/CS_01/

## 연습 🎲
위 내용들을 문제 풀이를 통해 적용해보겠습니다. 이번에 풀어볼 문제는 [백준 2003번](https://www.acmicpc.net/problem/2003)입니다.  

## 과제 🏓
#### PS 입문용 문제
완전 탐색, 그리디, DP 등을 간단하게 접해볼 수 있는 문제들입니다.  
가능한 지식 없이 풀 수 있는 문제들로 구성했으니 모두 풀어보길 권장합니다.  
(참고: 매겨진 난이도는 절대적인 것이 아니니, 참고로만 보세요!)  

[2217번: 로프](https://www.acmicpc.net/problem/2217) (Silver 4)  
[11399번: ATM](https://www.acmicpc.net/problem/11399) (Silver 3)  
[1931번: 회의실배정](https://www.acmicpc.net/problem/1931) (Silver 2)  
[9461번: 파도반 수열](https://www.acmicpc.net/problem/9461) (Silver 3)  
[14888번: 연산자 끼워넣기](https://www.acmicpc.net/problem/14888) (Silver 1)  
[1541번: 잃어버린 괄호](https://www.acmicpc.net/problem/1541) (Silver 2)  
[1946번: 신입 사원](https://www.acmicpc.net/problem/1946) (Silver 1)  

#### STL 복습
큐와 스택을 복습해보는 문제입니다.  

[2164번: 카드2](https://www.acmicpc.net/problem/2164) (Silver 4)  
[1406번: 에디터](https://www.acmicpc.net/problem/1406) (Silver 3)  

#### Challenge ⚡
더 어려운 문제를 풀어보고 싶은 실력자 분들을 위한 문제입니다.  
[3015번: 오아시스 재결합](https://www.acmicpc.net/problem/3015) (Gold 1)  
[18266번: Meetings](https://www.acmicpc.net/problem/18266) (Platinum 4)  
