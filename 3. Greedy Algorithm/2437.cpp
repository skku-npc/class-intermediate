#include <bits/stdc++.h>
using namespace std;

int n, range;
vector<int> v;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    v.resize(n);
    for (auto &i : v) cin >> i;
    sort(v.begin(), v.end());
    for (auto &i : v) {
        if (i > range + 1) break;
        range += i;
    }
    cout << range + 1 << endl;
}

/* 풀이: 그리디 알고리즘
 *
 * 완전 탐색을 고려해보자. 측정할 수 있는 무게를 모두 고려해보면, 각각의
 * 저울추는 무게에 포함되는/포함되지 않는 두 가지의 경우가 있으므로 O(2^N)의
 * 연산이 필요하다. 이는 불가능한 연산이다.
 *
 * 애초에 위 접근이 무의미한 것이, 우리는 측정할 수 없는 무게의 "최솟값"만 알면
 * 된다. 이 점에 집중하면, 1, 2, 3...의 오름차순으로 해당 무게를 나타낼 수 있는
 * 지 확인하며 최솟값을 얻는 접근을 떠올릴 수 있다.
 *
 * 하지만 1, 2, 3... 순으로 하나하나 가능한지 확인하는 접근은 현재 배운
 * 지식으로는 AC를 받을 수 없다. (다이내믹 프로그래밍 필요) 대신, 이보다 훨씬
 * 빠르고 간단한 접근이 있다.
 *
 * 1, 2, 3...의 무게 하나하나에 집중하는 것이 아니라, 무게추에 집중해보자.
 *
 * 무게추들을 배열 A에 저장해두었고, 내가 무게추 A[i]를 고려해야 하는 상황이라고
 * 하자. 무게추 A[0 ~ i-1]로 (1, 2, 3... w)의 무게를 측정할 수 있다고 하면,
 * A[i]까지 사용 시 (A[i], A[i] + 1, A[i] + 2, A[i] + 3... A[i] + w)의 무게를
 * 측정할 수 있다. 즉, A[i]가 w + 1보다 작거나 같으면 A[0 ~ i]의 무게추로 (1, 2,
 * 3, ... A[i] + w)의 무게를 측정할 수 있는 것이다.
 *
 * 만약 A를 오름차순으로 정렬했다면, 이를 greedy하게 적용할 수 있다.
 */